import numpy as np

POPULATION_SIZE, NUM_EPOCHS, MAX_ITER_WO_IMPROVEMENT = 10, 10000, 1000


class GeneticAlgorithm:
    def __init__(self, df, alpha):
        self.iter = 0
        self.iter_wo_improvement = 0
        self.max_epoch = NUM_EPOCHS
        self.max_iter_wo_improvement = MAX_ITER_WO_IMPROVEMENT
        self.population_size = POPULATION_SIZE
        self.df_returns = df.pct_change().dropna()
        self.portfolio_size = self.df_returns.shape[1]
        self.population = None
        self.children = []
        self.best_solution = None
        self.avg_return = None
        self.risk = None
        self.fitness = None
        self.num_candle_return = df.shape[0]
        self.alpha = alpha

    def generate_random_portfolio(self):
        """
        This function generates a random portfolio given its number of assets
        :return: randomly generated portfolio
        """
        portfolio = np.random.random(size=self.portfolio_size)
        portfolio = portfolio / sum(portfolio)
        return portfolio

    def fitness_function(self, portfolio):
        """
        Fitness Function for optimizing a portfolio.
        :param: portfolio: portfolio weights
        :return: Average Return normalized by volatility ~ Sharpe Ratio
        """
        risk = np.sqrt(np.linalg.multi_dot([portfolio, self.df_returns.cov(), portfolio]))
        avg_return = np.dot(self.df_returns.iloc[-self.num_candle_return:].mean(), portfolio)
        return self.alpha*avg_return + (1-self.alpha)*-risk

    def initial_population(self):
        """
        Creates the initial population of portfolios.
        :return: a list of randomly generated portfolios.
        """
        population = []
        for _ in range(self.population_size):
            portfolio = self.generate_random_portfolio()
            population.append({'sol': portfolio, 'fitness': self.fitness_function(portfolio)})
        self.population = population

    def select_parents(self):
        """
        Given a population select two individuals with uniform probability.
        :return: a list containing two portfolios
        """
        probability = np.array([i.get('fitness') for i in self.population])
        probability = np.divide(probability, sum(probability))
        if np.isnan(probability).any() or (probability <= 0).any():
            parents = np.random.choice(self.population, size=2, replace=False)
        else:
            parents = np.random.choice(self.population, size=2, replace=False, p=probability)
        return parents

    def cross_over(self, parents):
        """
        Given two portfolios, do a crossover to create a child portfolio.
        :param: parents: a list containing two portfolios
        :return: a child portfolio generated by mixing the weights from the parents
        """
        for _ in range(2):
            b = np.random.random()
            child_sol = (b * parents[0].get('sol') + (1 - b) * parents[1].get('sol')).copy()
            child = {
                'sol': child_sol,
                'fitness': self.fitness_function(child_sol)
            }
            self.children = np.append(self.children, child)

    def mutate_children(self):
        """With some probability randomly switch some of the child's weights.
        :return: mutated children
        """
        for portfolio in self.children:
            sol1 = portfolio.get('sol').copy()
            i = np.random.randint(self.portfolio_size)
            j = np.random.randint(self.portfolio_size)
            sol1[i], sol1[j] = sol1[j], sol1[i]
            child = {
                'sol': sol1,
                'fitness': self.fitness_function(sol1)
            }
            self.children = np.append(self.children, child)

            sol2 = portfolio.get('sol').copy()
            i = np.random.randint(self.portfolio_size)
            j = np.random.randint(self.portfolio_size)
            s = (sol2[i] + sol2[j]).copy()
            sol2[i] = s
            sol2[j] = 0
            child = {
                'sol': sol2,
                'fitness': self.fitness_function(sol2)
            }
            self.children = np.append(self.children, child)

    def generate_next_population(self):
        """
        Generates the next population by taking the best children and worst parents.
        :return: next population
        """
        best_children = sorted(self.children, key=lambda k: k['fitness'])[-2:]
        worst_parents = sorted(self.population, key=lambda k: k['fitness'])[2:]
        self.population = np.append(best_children, worst_parents)

    def check_stop_criteria(self):
        if self.iter > self.max_epoch or self.iter_wo_improvement > self.max_iter_wo_improvement:
            return False
        else:
            self.iter = self.iter + 1
            local_best = sorted(self.population, key=lambda k: k['fitness'])[-1].copy()
            if local_best.get('fitness') > self.best_solution.get('fitness'):
                self.iter_wo_improvement = 0
                self.best_solution = local_best
                self.fitness = self.best_solution.get('fitness')
                self.risk = np.sqrt(np.linalg.multi_dot(
                    [self.best_solution.get('sol'), self.df_returns.cov(), self.best_solution.get('sol')]))
                self.avg_return = np.dot(self.df_returns.mean(), self.best_solution.get('sol'))
            else:
                self.iter_wo_improvement = self.iter_wo_improvement + 1
            return True

    def normalize_population(self):
        norm_population = np.array([])
        for portfolio in self.population:
            norm_sol = portfolio.get('sol') / portfolio.get('sol').sum()
            norm_port = {
                'sol': norm_sol,
                'fitness': self.fitness_function(norm_sol)
            }
            norm_population = np.append(norm_population, norm_port)
        self.population = norm_population

    def optimize(self):
        """Run Genetic Algorithm
        :return: return the best population, its return and risk
        """
        self.initial_population()
        self.best_solution = sorted(self.population, key=lambda k: k['fitness'])[-1]

        while self.check_stop_criteria():
            self.children = []
            parents = self.select_parents()
            self.cross_over(parents)
            self.mutate_children()
            self.generate_next_population()
            self.normalize_population()

    def __call__(self):
        self.optimize()
        print("---------------------------")
        print(f"solution alpha {self.alpha} = ")
        print("Objective Function Value", self.best_solution.get("fitness"))
        print(f'R: {100*self.avg_return}%')
        print(f'Risco: {100*self.risk} %')
        print(f"Sharpe: {self.avg_return / self.risk}")
        return self.best_solution, self.avg_return, self.risk
